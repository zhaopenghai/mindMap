<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>ÂàùÁ∫ß‰ºöËÆ°ÂÆûÂä° - ËÄÉÁÇπÂØºÂõæ</title>
    <style>
      /* --- ÂÖ®Â±ÄÈáçÁΩÆ --- */
      * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }
      body,
      html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial,
          sans-serif;
        background-color: #f0f2f5;
      }

      /* --- ËÉåÊôØÁÇπÈòµÁΩëÊ†º (ÂèÇËÄÉÂõæÊ†∑Âºè) --- */
      .grid-bg {
        position: absolute;
        width: 100%;
        height: 100%;
        background-image: radial-gradient(#d1d5db 1.5px, transparent 1.5px);
        background-size: 24px 24px;
        z-index: 0;
      }

      /* --- ËßÜÂè£‰∏éÁîªÂ∏É --- */
      #viewport {
        width: 100%;
        height: 100%;
        position: relative;
        overflow: hidden;
        touch-action: none;
        cursor: grab;
        z-index: 1;
      }
      #canvas {
        position: absolute;
        top: 0;
        left: 0;
        transform-origin: 0 0;
        will-change: transform;
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
      }

      /* --- SVG ËøûÁ∫øÂ±Ç --- */
      svg {
        position: absolute;
        top: 0;
        left: 0;
        overflow: visible;
        pointer-events: none;
        z-index: 1;
      }
      path.connection {
        fill: none;
        stroke: #bdc3c7;
        stroke-width: 2px;
      }

      /* --- ËäÇÁÇπÈÄöÁî®Ê†∑Âºè --- */
      .node {
        position: absolute;
        z-index: 2;
        display: flex;
        align-items: center;
      }

      /* 1. Ê†πËäÇÁÇπ & ‰∏≠Èó¥Â±ÇÁ∫ß (Ê∑±Ëâ≤ËÉ∂ÂõäÊ†∑Âºè) */
      .node-pill {
        background-color: #34495e;
        color: white;
        padding: 0 12px;
        display: flex;
        align-content: center;
        justify-content: center;
        border-radius: 8px;
        font-size: 12px;
        font-weight: 600;
        box-shadow: 0 4px 10px rgba(44, 62, 80, 0.3);
        cursor: pointer;
        border: 1px solid #2c3e50;
        height: 50px;
        width: 146px;
        line-height: 20px;

        /* Â§öË°åÁúÅÁï•Ê†∏ÂøÉ */
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 2;

        overflow: hidden;
        word-break: break-word;
      }

      .is-root .node-pill {
        font-size: 12px;
        /*padding: 12px 24px;*/
        background-color: #2c3e50;
      }

      /* 2. Âè∂Â≠êËäÇÁÇπ (ÁôΩËâ≤Âç°ÁâáÊ†∑Âºè) */
      .node-card {
        background: white;
        width: 260px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        border-left: 5px solid #3498db;
        padding: 12px 14px;
        cursor: default;
      }
      .card-title {
        font-size: 15px;
        font-weight: bold;
        color: #333;
        margin-bottom: 6px;
      }
      .card-desc {
        font-size: 12px;
        color: #666;
        line-height: 1.5;
        margin-bottom: 12px;
      }

      .card-actions {
        display: flex;
        gap: 10px;
      }
      .action-btn {
        flex: 1;
        background: #f7f9fa;
        border: none;
        border-radius: 4px;
        padding: 6px 0;
        font-size: 12px;
        color: #3498db;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 4px;
        font-weight: 600;
        cursor: pointer;
      }

      /* --- ÊäòÂè†/Â±ïÂºÄ ÊåâÈíÆ --- */
      .toggle-btn {
        position: absolute;
        right: -12px;
        top: 15px;
        /*transform: translateY(-50%);*/
        width: 20px;
        height: 20px;
        background: #95a5a6;
        color: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        border: 2px solid #f0f2f5;
        cursor: pointer;
        z-index: 10;
      }
      .toggle-btn.collapsed {
        background: #3498db;
      }

      /* --- ‰∏ªÊéßÂà∂Ê†è --- */
      .main-controls {
        display: flex;
        flex-direction: column;
        justify-content: space-evenly;
        background-color: rgba(0, 0, 0, 0.5);
        border-radius: 20px;
        width: 40px;
        height: 180px;
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 100;
      }

      .control-btn {
        background-color: transparent;
        border: none;
        cursor: pointer;
        position: relative;
      }

      .control-btn-img {
        width: 20px;
        height: 20px;
        pointer-events: none;
      }

      /* --- Â±ïÂºÄ/ÊäòÂè†ÂàáÊç¢ÊåâÈíÆÊ†∑Âºè --- */
      #toggle-expand-btn {
        position: relative;
      }

      #toggle-expand-btn .control-btn-img {
        width: 20px;
        height: 20px;
        transition: opacity 0.3s ease;
      }

      #toggle-expand-btn .zk-icon {
        opacity: 1;
        visibility: visible;
      }

      #toggle-expand-btn .sx-icon {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        opacity: 0;
        visibility: hidden;
      }

      #toggle-expand-btn.expanded .zk-icon {
        opacity: 0;
        visibility: hidden;
      }

      #toggle-expand-btn.expanded .sx-icon {
        opacity: 1;
        visibility: visible;
      }

      #toggle-expand-btn.collapsed .zk-icon {
        opacity: 1;
        visibility: visible;
      }

      #toggle-expand-btn.collapsed .sx-icon {
        opacity: 0;
        visibility: hidden;
      }

      /* --- ÈáçÁΩÆËßÜÂõæÊåâÈíÆ --- */
      .reset-view-btn {
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: white;
        border: none;
        border-radius: 8px;
        padding: 8px 16px;
        font-size: 14px;
        font-weight: 600;
        color: #34495e;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        cursor: pointer;
        z-index: 100;
        transition: all 0.2s ease;
      }

      .reset-view-btn:hover {
        background-color: #f7f9fa;
        transform: translateY(-1px);
      }

      .reset-view-btn:active {
        transform: translateY(1px);
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* --- RNÈÄö‰ø°Ë∞ÉËØïÈù¢Êùø --- */
      .rn-debug {
        position: fixed;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 8px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 10000;
        display: none;
        max-width: 200px;
        word-break: break-all;
      }
      /* Âú®ÂéüÊúâÊ†∑ÂºèÂü∫Á°Ä‰∏äÊ∑ªÂä† */
      .node-container {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
      }

      .node-desc {
        background-color: rgba(255, 255, 255, 0.9);
        border: 1px solid #e0e0e0;
        border-radius: 6px;
        padding: 6px 10px;
        margin-top: 6px;
        font-size: 11px;
        line-height: 1.5;
        color: #666;
        max-width: 146px;
        max-height: 60px;
        overflow: hidden;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 3;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      }
    </style>
  </head>
  <body>
    <div class="grid-bg"></div>

    <div id="viewport">
      <div id="canvas">
        <svg id="svg-layer"></svg>
        <div id="dom-layer"></div>
      </div>
    </div>

    <!-- ‰∏ªÊéßÂà∂Ê†èÔºà4‰∏™ÂõæÊ†áÊåâÈíÆÔºâ -->
    <div class="main-controls">
      <!-- ÊîæÂ§ß -->
      <button class="control-btn" id="zoom-in-btn">
        <img src="./assets/fd.png" alt="ÊîæÂ§ß" class="control-btn-img" />
      </button>

      <!-- Áº©Â∞è -->
      <button class="control-btn" id="zoom-out-btn">
        <img src="./assets/ss.png" alt="Áº©Â∞è" class="control-btn-img" />
      </button>

      <!-- Â±ïÂºÄ/ÊäòÂè†ÂàáÊç¢ÊåâÈíÆ -->
      <button class="control-btn" id="toggle-expand-btn">
        <img src="./assets/zk.png" alt="Â±ïÂºÄÂÖ®ÈÉ®" class="control-btn-img zk-icon" />
        <img src="./assets/sx.png" alt="ÊäòÂè†ÂÖ®ÈÉ®" class="control-btn-img sx-icon" />
      </button>

      <!-- ‰∏ãËΩΩÂÆåÊï¥ÂØºÂõæ -->
      <button class="control-btn" id="download-full-btn">
        <img src="./assets/xizai.png" alt="‰∏ãËΩΩÂÆåÊï¥ÂØºÂõæ" class="control-btn-img" />
      </button>
    </div>

    <!-- ÈáçÁΩÆËßÜÂõæÊåâÈíÆÔºàÂçïÁã¨‰øùÁïôÔºâ -->
    <button class="reset-view-btn" id="zoom-reset">ÈáçÁΩÆËßÜÂõæ</button>

    <!-- RNÈÄö‰ø°Ë∞ÉËØïÈù¢Êùø -->
    <div class="rn-debug" id="rn-debug"></div>

    <script>
      // --- 2. ÈÖçÁΩÆÂèÇÊï∞ ---
      const CONFIG = {
        nodeXGap: 50,
        nodeYGap: 20,
        cardWidth: 260,
        pillWidth: 160,
        cardHeight: 50,
        pillHeight: 50,
      };

      // --- 3. Ê†∏ÂøÉÂèòÈáè ---
      let flatNodes = [];
      let isAllExpanded = false;
      let isLoadingData = false;
      const canvas = document.getElementById('canvas');
      const domLayer = document.getElementById('dom-layer');
      const svgLayer = document.getElementById('svg-layer');
      const viewport = document.getElementById('viewport');
      const debugPanel = document.getElementById('rn-debug');

      // --- ÊñáÊú¨Ê∏ÖÁêÜÂáΩÊï∞ ---
      function cleanNodeText(text) {
        if (!text) return '';

        return text
          .replace(/\r\n/g, ' ')
          .replace(/\r/g, ' ')
          .replace(/\n/g, ' ')
          .replace(/\s+/g, ' ')
          .trim();
      }

      // --- RN WebView ÈÄö‰ø°Êé•Âè£ ---
      const RNInterface = {
        // Êñ∞Â¢ûÔºöÊ∞¥Âç∞ÈÖçÁΩÆ
        WATERMARK_CONFIG: {
          enabled: true,
          text: 'ÊÄùÁª¥ÂØºÂõæ',
          fontSize: 16,
          opacity: 0.15, //ËÆæÁΩÆÈÄèÊòéÂ∫¶
          color: '#000000',
          spacing: 200, // Ê∞¥Âç∞‰πãÈó¥ÁöÑÈó¥Ë∑ù
          angle: -20, // ÊóãËΩ¨ËßíÂ∫¶
        },

        MAX_BASE64_SIZE: 1500000,

        getOptimizedQuality: function (quality = 0.6) {
          return Math.max(0.3, Math.min(1.0, quality));
        },

        checkBase64Size: function (base64) {
          const size = base64.length;
          const fileSizeMB = ((size * 0.75) / 1024 / 1024).toFixed(2);

          return {
            size: size,
            isSafe: size <= this.MAX_BASE64_SIZE,
            fileSizeMB: fileSizeMB,
            maxSizeMB: ((this.MAX_BASE64_SIZE * 0.75) / 1024 / 1024).toFixed(2),
          };
        },

        optimizeBase64Size: async function (base64, context = 'full_map') {
          const checkResult = this.checkBase64Size(base64);

          if (checkResult.isSafe) {
            return base64;
          }

          try {
            const img = new Image();

            return new Promise(resolve => {
              img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);

                const qualitySteps = [0.5, 0.4, 0.3, 0.2];
                let optimizedBase64 = base64;

                for (let i = 0; i < qualitySteps.length; i++) {
                  const quality = qualitySteps[i];
                  const testBase64 = canvas.toDataURL('image/png', quality);
                  const cleaned = testBase64.replace(/\n/g, '');

                  const newCheck = this.checkBase64Size(cleaned);

                  if (newCheck.isSafe) {
                    optimizedBase64 = cleaned;
                    break;
                  }

                  if (i === qualitySteps.length - 1) {
                    optimizedBase64 = cleaned;
                  }
                }

                resolve(optimizedBase64);
              };

              img.onerror = () => {
                resolve(base64);
              };

              img.src = base64;
            });
          } catch (error) {
            return base64;
          }
        },

        // Êñ∞Â¢ûÔºöÁªòÂà∂Ê∞¥Âç∞ÂáΩÊï∞
        drawWatermark: function (ctx, width, height) {
          if (!this.WATERMARK_CONFIG.enabled) return;

          const { text, fontSize, opacity, color, spacing, angle } = this.WATERMARK_CONFIG;

          ctx.save();
          ctx.globalAlpha = opacity;
          ctx.fillStyle = color;
          ctx.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          // ËÆ°ÁÆóÊ∞¥Âç∞ÈúÄË¶ÅÁöÑÁ©∫Èó¥
          const textWidth = ctx.measureText(text).width;
          const textHeight = fontSize;

          // ËÆ°ÁÆóÊ∞¥Âç∞Êï∞Èáè
          const cols = Math.ceil(width / spacing) + 1;
          const rows = Math.ceil(height / spacing) + 1;

          // ÊóãËΩ¨ÁîªÂ∏É
          const radians = (angle * Math.PI) / 180;
          ctx.translate(width / 2, height / 2);
          ctx.rotate(radians);
          ctx.translate(-width / 2, -height / 2);

          // ÁªòÂà∂ÁΩëÊ†ºÊ∞¥Âç∞
          for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
              const x = i * spacing;
              const y = j * spacing;

              // ‰∫§Èîô‰ΩçÁΩÆ‰ΩøÊ∞¥Âç∞Êõ¥Ëá™ÁÑ∂
              const offsetX = (j % 2) * (spacing / 2);
              const drawX = x + offsetX;
              const drawY = y + textHeight / 2;

              ctx.fillText(text, drawX, drawY);
            }
          }

          ctx.restore();
        },

        // Êñ∞Â¢ûÔºöÊ∑ªÂä†Ê∞¥Âç∞Âà∞ÂõæÁâá
        addWatermarkToImage: async function (imageData, width, height) {
          return new Promise(resolve => {
            const img = new Image();

            img.onload = () => {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');

              canvas.width = width;
              canvas.height = height;

              // ÁªòÂà∂ÂéüÂßãÂõæÁâá
              ctx.drawImage(img, 0, 0, width, height);

              // ÁªòÂà∂Ê∞¥Âç∞
              this.drawWatermark(ctx, width, height);

              // ËøîÂõûÂ∏¶Ê∞¥Âç∞ÁöÑBase64
              const watermarkedBase64 = canvas.toDataURL('image/png', 0.9);
              resolve(watermarkedBase64);
            };

            img.onerror = () => {
              resolve(imageData);
            };

            img.src = imageData;
          });
        },

        requestData: function () {
          this.postMessage('request_data', {
            timestamp: Date.now(),
          });
        },

        updateData: function (newData) {
          try {
            isLoadingData = true;

            function cleanDataRecursive(node) {
              if (node.text) {
                node.text = cleanNodeText(node.text);
              }
              if (node.title) {
                node.title = cleanNodeText(node.title);
              }
              if (node.desc) {
                node.desc = cleanNodeText(node.desc);
              }
              if (node.children) {
                node.children.forEach(child => cleanDataRecursive(child));
              }
            }

            cleanDataRecursive(newData);
            mindMapData = newData;
            isAllExpanded = false;
            initDataRecursive(mindMapData, 0);
            render();
            updateExpandCollapseButton();
            isLoadingData = false;
          } catch (error) {
            isLoadingData = false;
          }
        },

        postMessage: function (type, data = {}) {
          const message = {
            type: type,
            data: data,
            timestamp: Date.now(),
          };

          try {
            if (window.ReactNativeWebView && window.ReactNativeWebView.postMessage) {
              window.ReactNativeWebView.postMessage(JSON.stringify(message));
            } else if (window.postMessage) {
              window.postMessage(JSON.stringify(message), '*');
            } else {
              if (type === 'save_image') {
                this.showBrowserDownload(data.imageData);
              }
            }
          } catch (error) {
            // ÈîôËØØÂ§ÑÁêÜ
          }
        },

        setupMessageListener: function () {
          window.addEventListener('message', event => {
            try {
              const message = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;

              if (message.type === 'request_screenshot') {
                const { viewType, quality = 0.6 } = message.data || {};
                this.handleScreenshotRequest(viewType, quality);
              } else if (message.type === 'update_data') {
                const { data } = message.data || {};
                if (data) {
                  this.updateData(data);
                }
              } else if (message.type === 'clear_data') {
                this.clearData();
              }
            } catch (error) {
              // ÈîôËØØÂ§ÑÁêÜ
            }
          });

          document.addEventListener('message', event => {
            try {
              const message = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;

              if (message.type === 'request_screenshot') {
                const { viewType, quality = 0.6 } = message.data || {};
                this.handleScreenshotRequest(viewType, quality);
              } else if (message.type === 'update_data') {
                const { data } = message.data || {};
                if (data) {
                  this.updateData(data);
                }
              } else if (message.type === 'clear_data') {
                this.clearData();
              }
            } catch (error) {
              // ÈîôËØØÂ§ÑÁêÜ
            }
          });

          document.addEventListener('visibilitychange', () => {
            if (!document.hidden && !isLoadingData) {
              setTimeout(() => {
                this.requestData();
              }, 100);
            }
          });
        },

        clearData: function () {
          mindMapData = {
            id: 'root',
            type: 'root',
            text: 'ÊöÇÊó†Êï∞ÊçÆ',
            children: [],
          };

          initDataRecursive(mindMapData, 0);
          render();
          updateExpandCollapseButton();
        },

        // ‰øÆÊîπÔºöÂ§ÑÁêÜÊà™ÂõæËØ∑Ê±Ç - Ê∑ªÂä†Ê∞¥Âç∞
        handleScreenshotRequest: async function (viewType = 'current', quality = 0.6) {
          const optimizedQuality = this.getOptimizedQuality(quality);

          try {
            let imageData;
            const context = viewType === 'full' ? 'full_map' : 'current_view';

            if (viewType === 'full') {
              imageData = await this.generateFullMapScreenshot(optimizedQuality);
            } else {
              imageData = await this.generateCurrentViewScreenshot(optimizedQuality);
            }

            // Ê∏ÖÁêÜÊç¢Ë°åÁ¨¶
            const cleanedImageData = imageData.replace(/\n/g, '');

            // Ê∑ªÂä†Ê∞¥Âç∞
            let watermarkedImageData = cleanedImageData;
            if (this.WATERMARK_CONFIG.enabled) {
              try {
                const img = new Image();
                await new Promise(resolve => {
                  img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    canvas.width = img.width;
                    canvas.height = img.height;

                    // ÁªòÂà∂ÂéüÂßãÂõæÁâá
                    ctx.drawImage(img, 0, 0);

                    // ÁªòÂà∂Ê∞¥Âç∞
                    this.drawWatermark(ctx, img.width, img.height);

                    // Ëé∑ÂèñÂ∏¶Ê∞¥Âç∞ÁöÑÂõæÁâá
                    watermarkedImageData = canvas.toDataURL('image/png', optimizedQuality);
                    resolve();
                  };
                  img.onerror = () => {
                    watermarkedImageData = cleanedImageData;
                    resolve();
                  };
                  img.src = cleanedImageData;
                });
              } catch (watermarkError) {
                watermarkedImageData = cleanedImageData;
              }
            }

            // Ê£ÄÊü•Âπ∂‰ºòÂåñÂ§ßÂ∞è
            const optimizedImageData = await this.optimizeBase64Size(watermarkedImageData, context);

            // ÂèëÈÄÅÊà™ÂõæÊï∞ÊçÆÂà∞RN
            this.postMessage('save_image', {
              imageData: optimizedImageData,
              viewType: viewType,
              quality: optimizedQuality,
              optimized: cleanedImageData !== optimizedImageData,
              originalSize: cleanedImageData.length,
              finalSize: optimizedImageData.length,
              watermarked:
                this.WATERMARK_CONFIG.enabled && cleanedImageData !== watermarkedImageData,
            });

            setTimeout(() => {
              RNInterface.postMessage('download_started', {
                action: 'full_map_error',
                timestamp: Date.now(),
                buttonId: 'download-full-btn',
              });
            }, 500);
          } catch (error) {
            RNInterface.postMessage('download_started', {
              action: 'full_map_error',
              timestamp: Date.now(),
              buttonId: 'download-full-btn',
            });
            this.postMessage('save_image_error', {
              error: error.message,
              viewType: viewType,
            });
          }
        },

        // ‰øÆÊîπÔºöÁîüÊàêÂΩìÂâçËßÜÂõæÊà™Âõæ
        generateCurrentViewScreenshot: async function (quality = 0.6) {
          const optimizedQuality = this.getOptimizedQuality(quality);
          const rect = viewport.getBoundingClientRect();
          const width = rect.width;
          const height = rect.height;

          const canvas = document.createElement('canvas');
          canvas.width = width * 2;
          canvas.height = height * 2;
          const ctx = canvas.getContext('2d');

          ctx.fillStyle = '#f0f2f5';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          this.drawGridBackground(ctx, canvas.width, canvas.height);

          const transform = window.getComputedStyle(canvas.parentElement).transform;
          const matrix = new DOMMatrix(transform);

          ctx.setTransform(
            matrix.a * 2,
            matrix.b * 2,
            matrix.c * 2,
            matrix.d * 2,
            matrix.e * 2,
            matrix.f * 2,
          );

          this.drawMindMapContent(ctx);
          ctx.setTransform(1, 0, 0, 1, 0, 0);

          return canvas.toDataURL('image/png', optimizedQuality);
        },

        // ‰øÆÊîπÔºöÁîüÊàêÂÆåÊï¥ÊÄùÁª¥ÂØºÂõæÊà™Âõæ
        generateFullMapScreenshot: async function (quality = 0.6) {
          const optimizedQuality = this.getOptimizedQuality(quality);
          const bounds = this.getMindMapBounds();
          const padding = 40;

          const originalWidth = Math.max(100, bounds.width + padding * 2);
          const originalHeight = Math.max(100, bounds.height + padding * 2);

          let targetScale = 1.0;
          let targetWidth = originalWidth;
          let targetHeight = originalHeight;

          const originalPixels = originalWidth * originalHeight;

          if (originalPixels < 2000000) {
            targetScale = 4.0;
            console.log('‚ú® Â∞èÂõæÊ®°ÂºèÔºö‰ΩøÁî®3ÂÄçÈ´òÊ∏Ö');
          } else if (originalPixels < 5000000) {
            targetScale = 3.0;
            console.log('üì± ‰∏≠ÂõæÊ®°ÂºèÔºö‰ΩøÁî®2ÂÄçÈ´òÊ∏Ö');
          } else if (originalPixels < 10000000) {
            targetScale = 2.5;
            console.log('üñ•Ô∏è Â§ßÂõæÊ®°ÂºèÔºö‰ΩøÁî®1.5ÂÄç');
          } else {
            targetScale = 2.0;
            console.log('üèóÔ∏è Ë∂ÖÂ§ßÂõæÊ®°ÂºèÔºö‰øùÊåÅÂéüÂ∞∫ÂØ∏');
          }

          targetWidth = Math.floor(originalWidth * targetScale);
          targetHeight = Math.floor(originalHeight * targetScale);

          const SAFE_MAX_DIMENSION = 60000;
          const SAFE_MAX_PIXELS = 600000000;

          if (
            targetWidth > SAFE_MAX_DIMENSION ||
            targetHeight > SAFE_MAX_DIMENSION ||
            targetWidth * targetHeight > SAFE_MAX_PIXELS
          ) {
            const widthRatio = SAFE_MAX_DIMENSION / targetWidth;
            const heightRatio = SAFE_MAX_DIMENSION / targetHeight;
            const pixelRatio = Math.sqrt(SAFE_MAX_PIXELS / (targetWidth * targetHeight));

            const safeScale = Math.min(widthRatio, heightRatio, pixelRatio);

            targetWidth = Math.floor(targetWidth * safeScale);
            targetHeight = Math.floor(targetHeight * safeScale);
            targetScale = targetScale * safeScale;
          }

          const canvas = document.createElement('canvas');
          canvas.width = targetWidth;
          canvas.height = targetHeight;
          const ctx = canvas.getContext('2d');

          if (!ctx) {
            throw new Error('‚ùå Êó†Ê≥ïËé∑ÂèñCanvas‰∏ä‰∏ãÊñá');
          }

          ctx.fillStyle = '#f0f2f5';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          this.drawGridBackground(ctx, canvas.width, canvas.height);

          if (targetScale !== 1.0) {
            ctx.scale(targetScale, targetScale);
          }

          this.drawMindMapToCanvas(ctx, bounds, padding);

          const sampleData = ctx.getImageData(
            Math.min(50, canvas.width - 1),
            Math.min(50, canvas.height - 1),
            1,
            1,
          ).data;

          const finalQuality = Math.min(0.9, Math.max(0.8, optimizedQuality));

          const base64 = canvas.toDataURL('image/png', finalQuality);

          if (base64.length < 5000) {
            const testCanvas = document.createElement('canvas');
            testCanvas.width = 800;
            testCanvas.height = 600;
            const testCtx = testCanvas.getContext('2d');

            testCtx.fillStyle = '#3498db';
            testCtx.fillRect(0, 0, 800, 600);

            testCtx.fillStyle = 'white';
            testCtx.font = 'bold 28px Arial';
            testCtx.textAlign = 'center';
            testCtx.fillText('ÊÄùÁª¥ÂØºÂõæÊà™Âõæ', 400, 200);

            testCtx.font = '20px Arial';
            testCtx.fillText(`ÂéüÂßãÂ∞∫ÂØ∏: ${originalWidth}√ó${originalHeight}`, 400, 250);
            testCtx.fillText(`ÁõÆÊ†áÂ∞∫ÂØ∏: ${targetWidth}√ó${targetHeight}`, 400, 300);
            testCtx.fillText(`Áº©ÊîæÊØî‰æã: ${targetScale.toFixed(2)}x`, 400, 350);

            testCtx.font = '18px Arial';
            testCtx.fillStyle = '#f1c40f';
            testCtx.fillText('‚ö†Ô∏è Â¶ÇÊûúÁúã‰∏çÂà∞ÂØºÂõæÂÜÖÂÆπÔºåËØ∑Ê£ÄÊü•ËäÇÁÇπÊï∞ÊçÆ', 400, 450);

            return testCanvas.toDataURL('image/png', 0.95);
          }
          return base64;
        },

        drawGridBackground: function (ctx, width, height) {
          const gridSize = 24 * 2;
          const dotSize = 1.5 * 2;

          ctx.fillStyle = '#d1d5db';

          for (let x = 0; x < width; x += gridSize) {
            for (let y = 0; y < height; y += gridSize) {
              ctx.beginPath();
              ctx.arc(x, y, dotSize, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        },

        drawMindMapContent: function (ctx) {
          this.drawConnections(ctx);
          this.drawNodes(ctx);
        },

        drawConnections: function (ctx) {
          ctx.strokeStyle = '#bdc3c7';
          ctx.lineWidth = 2;
          ctx.lineCap = 'round';

          flatNodes.forEach(node => {
            if (node.children && node.children.length > 0 && !node.collapsed) {
              const startX = node.x + node.w;
              const startY = node.y;

              node.children.forEach(child => {
                const endX = child.x;
                const endY = child.y;

                const cpOffset = CONFIG.nodeXGap * 0.6;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.bezierCurveTo(startX + cpOffset, startY, endX - cpOffset, endY, endX, endY);
                ctx.stroke();
              });
            }
          });
        },

        drawNodes: function (ctx) {
          flatNodes.forEach(node => {
            const x = node.x;
            const y = node.y - node.h / 2;

            if (node.type === 'leaf') {
              this.drawCardNode(ctx, x, y, node);
            } else {
              this.drawPillNode(ctx, x, y, node);
            }
          });
        },

        drawCardNode: function (ctx, x, y, node) {
          const width = CONFIG.cardWidth;
          const height = 80;
          const borderRadius = 8;
          const padding = 14;

          ctx.fillStyle = '#ffffff';
          this.drawRoundedRect(ctx, x, y, width, height, borderRadius);
          ctx.fill();

          ctx.fillStyle = '#3498db';
          ctx.fillRect(x, y + borderRadius, 5, height - borderRadius * 2);

          ctx.shadowColor = 'rgba(0, 0, 0, 0.08)';
          ctx.shadowBlur = 12;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 4;

          ctx.fillStyle = '#ffffff';
          this.drawRoundedRect(ctx, x, y, width, height, borderRadius);
          ctx.fill();

          ctx.shadowColor = 'transparent';
          ctx.shadowBlur = 0;

          ctx.fillStyle = '#666666';
          ctx.font =
            '13px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
          ctx.textBaseline = 'middle';
          ctx.textAlign = 'left';

          const descMaxWidth = width - padding * 2;
          const lineHeight = 18;
          const maxHeight = height - padding * 2;

          const cleanDesc = cleanNodeText(node.desc || node.title || '');
          this.wrapText(
            ctx,
            cleanDesc,
            x + padding,
            y + height / 2,
            descMaxWidth,
            lineHeight,
            false,
          );
        },

        drawPillNode: function (ctx, x, y, node) {
          const width = CONFIG.pillWidth;
          const height = CONFIG.pillHeight;
          const borderRadius = 8;

          const isRoot = node.type === 'root';
          ctx.fillStyle = isRoot ? '#2c3e50' : '#34495e';

          this.drawRoundedRect(ctx, x, y, width, height, borderRadius);
          ctx.fill();

          ctx.strokeStyle = '#2c3e50';
          ctx.lineWidth = 1;
          this.drawRoundedRect(ctx, x, y, width, height, borderRadius);
          ctx.stroke();

          ctx.shadowColor = 'rgba(44, 62, 80, 0.3)';
          ctx.shadowBlur = 10;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 4;

          ctx.fillStyle = isRoot ? '#2c3e50' : '#34495e';
          this.drawRoundedRect(ctx, x, y, width, height, borderRadius);
          ctx.fill();

          ctx.shadowColor = 'transparent';
          ctx.shadowBlur = 0;

          ctx.fillStyle = '#ffffff';
          ctx.font = isRoot
            ? 'bold 16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif'
            : 'bold 14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          const textX = x + width / 2;
          const textY = y + height / 2;
          const textMaxWidth = width - 20;
          const lineHeight = 16;

          const cleanText = cleanNodeText(node.text || '');
          const textHeight = this.calcTextHeight(ctx, cleanText, textMaxWidth, lineHeight);
          const adjustedTextY = textY - (textHeight - lineHeight) / 2;

          this.wrapText(ctx, cleanText, textX, adjustedTextY, textMaxWidth, lineHeight, true);

          ctx.textAlign = 'left';
        },

        drawRoundedRect: function (ctx, x, y, width, height, radius) {
          ctx.beginPath();
          ctx.moveTo(x + radius, y);
          ctx.lineTo(x + width - radius, y);
          ctx.arcTo(x + width, y, x + width, y + radius, radius);
          ctx.lineTo(x + width, y + height - radius);
          ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
          ctx.lineTo(x + radius, y + height);
          ctx.arcTo(x, y + height, x, y + height - radius, radius);
          ctx.lineTo(x, y + radius);
          ctx.arcTo(x, y, x + radius, y, radius);
          ctx.closePath();
        },

        wrapText: function (ctx, text, x, y, maxWidth, lineHeight, center = false) {
          if (!text || text.trim() === '') return y;

          const characters = text.split('');
          let line = '';
          let lineCount = 0;
          const originalTextAlign = ctx.textAlign;

          for (let i = 0; i < characters.length; i++) {
            const testLine = line + characters[i];
            const metrics = ctx.measureText(testLine);
            const testWidth = metrics.width;

            if ((testWidth > maxWidth && line.length > 0) || characters[i] === '\n') {
              if (center) {
                ctx.textAlign = 'center';
                ctx.fillText(line, x, y + lineCount * lineHeight);
                ctx.textAlign = originalTextAlign;
              } else {
                ctx.fillText(line, x, y + lineCount * lineHeight);
              }

              line = characters[i] === '\n' ? '' : characters[i];
              lineCount++;
            } else {
              line = testLine;
            }
          }

          if (line.trim() !== '') {
            if (center) {
              ctx.textAlign = 'center';
              ctx.fillText(line, x, y + lineCount * lineHeight);
              ctx.textAlign = originalTextAlign;
            } else {
              ctx.fillText(line, x, y + lineCount * lineHeight);
            }
          }

          return y + (lineCount + 1) * lineHeight;
        },

        calcTextHeight: function (ctx, text, maxWidth, lineHeight) {
          if (!text || text.trim() === '') return 0;

          const characters = text.split('');
          let line = '';
          let lineCount = 0;

          for (let i = 0; i < characters.length; i++) {
            const testLine = line + characters[i];
            const metrics = ctx.measureText(testLine);

            if ((metrics.width > maxWidth && line.length > 0) || characters[i] === '\n') {
              line = characters[i] === '\n' ? '' : characters[i];
              lineCount++;
            } else {
              line = testLine;
            }
          }

          if (line.trim() !== '') {
            lineCount++;
          }

          return lineCount * lineHeight;
        },

        truncateTextToLines: function (ctx, text, maxWidth, maxLines) {
          if (!text || text.trim() === '' || maxLines <= 0) return '';

          const characters = text.split('');
          let line = '';
          let lineCount = 0;
          let result = '';

          for (let i = 0; i < characters.length; i++) {
            const testLine = line + characters[i];
            const metrics = ctx.measureText(testLine);

            if ((metrics.width > maxWidth && line.length > 0) || characters[i] === '\n') {
              lineCount++;
              if (lineCount >= maxLines) {
                result += this.addEllipsisToLine(ctx, line, maxWidth);
                return result;
              }

              result += line + (characters[i] === '\n' ? '' : ' ');
              line = characters[i] === '\n' ? '' : characters[i];
            } else {
              line = testLine;
            }
          }

          if (line.trim() !== '') {
            lineCount++;
            if (lineCount <= maxLines) {
              result += line;
            } else {
              result += this.addEllipsisToLine(ctx, '', maxWidth);
            }
          }

          return result;
        },

        addEllipsisToLine: function (ctx, line, maxWidth) {
          const ellipsis = '...';
          const ellipsisWidth = ctx.measureText(ellipsis).width;

          if (ctx.measureText(line).width + ellipsisWidth <= maxWidth) {
            return line + ellipsis;
          }

          let truncated = line;
          while (truncated.length > 0 && ctx.measureText(truncated + ellipsis).width > maxWidth) {
            truncated = truncated.substring(0, truncated.length - 1);
          }

          return truncated + ellipsis;
        },

        getMindMapBounds: function () {
          let minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;

          flatNodes.forEach(node => {
            const x = node.x;
            const y = node.y - node.h / 2;
            const right = x + node.w;
            const bottom = y + node.h;

            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, right);
            maxY = Math.max(maxY, bottom);
          });
          return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY,
          };
        },

        drawMindMapToCanvas: function (ctx, bounds, padding) {
          const offsetX = padding - bounds.x;
          const offsetY = padding - bounds.y;

          flatNodes.forEach(node => {
            const x = node.x + offsetX;
            const y = node.y - node.h / 2 + offsetY;

            if (node.type === 'leaf') {
              this.drawCardNode(ctx, x, y, node);
            } else {
              this.drawPillNode(ctx, x, y, node);
            }
          });

          ctx.strokeStyle = '#bdc3c7';
          ctx.lineWidth = 2;
          ctx.lineCap = 'round';

          flatNodes.forEach(node => {
            if (node.children && node.children.length > 0 && !node.collapsed) {
              const startX = node.x + offsetX + node.w;
              const startY = node.y + offsetY;

              node.children.forEach(child => {
                const endX = child.x + offsetX;
                const endY = child.y + offsetY;

                const cpOffset = CONFIG.nodeXGap * 0.6;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.bezierCurveTo(startX + cpOffset, startY, endX - cpOffset, endY, endX, endY);
                ctx.stroke();
              });
            }
          });
        },

        showBrowserDownload: function (imageData) {
          const link = document.createElement('a');
          link.download = 'ÊÄùÁª¥ÂØºÂõæ-' + new Date().toISOString().split('T')[0] + '.png';
          link.href = imageData;
          link.click();
        },

        debug: function (...args) {
          if (debugPanel) {
            debugPanel.textContent = args
              .map(arg => (typeof arg === 'object' ? JSON.stringify(arg) : arg))
              .join(' ');
            debugPanel.style.display = 'block';
            setTimeout(() => {
              debugPanel.style.display = 'none';
            }, 3000);
          }
        },
      };

      // --- 4. Â¢ûÂº∫ÁöÑÁº©ÊîæÁÆ°ÁêÜÂô® ---
      class EnhancedZoomManager {
        constructor() {
          this.scale = 1.0;
          this.translateX = 0;
          this.translateY = 0;
          this.minScale = 0.2;
          this.maxScale = 3.0;
          this.scaleStep = 0.1;

          this.isPinching = false;
          this.isDragging = false;
          this.wasPinching = false;
          this.pinchEndTime = 0;

          this.initialPinch = {
            distance: 0,
            scale: 1.0,
            centerX: 0,
            centerY: 0,
            translateX: 0,
            translateY: 0,
          };

          this.dragStart = { x: 0, y: 0 };
          this.activeTouches = new Map();
        }

        updateDisplay() {
          // ÁßªÈô§‰∫ÜÁº©ÊîæÁôæÂàÜÊØîÊòæÁ§∫
        }

        applyTransform() {
          const transform = `translate3d(${this.translateX}px, ${this.translateY}px, 0) scale(${this.scale})`;
          canvas.style.transform = transform;
          canvas.style.webkitTransform = transform;
        }

        smoothTransform(targetTranslateX, targetTranslateY, targetScale, duration = 300) {
          const startTranslateX = this.translateX;
          const startTranslateY = this.translateY;
          const startScale = this.scale;
          const startTime = Date.now();

          const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const ease = 1 - Math.pow(1 - progress, 3);

            this.translateX = startTranslateX + (targetTranslateX - startTranslateX) * ease;
            this.translateY = startTranslateY + (targetTranslateY - startTranslateY) * ease;
            this.scale = startScale + (targetScale - startScale) * ease;

            this.applyTransform();

            if (progress < 1) {
              requestAnimationFrame(animate);
            }
          };

          animate();
        }

        zoomBy(delta) {
          const rect = viewport.getBoundingClientRect();
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;

          const targetScale = Math.max(this.minScale, Math.min(this.maxScale, this.scale + delta));
          if (Math.abs(targetScale - this.scale) < 0.001) return;

          const canvasX = (centerX - this.translateX) / this.scale;
          const canvasY = (centerY - this.translateY) / this.scale;

          const targetTranslateX = centerX - canvasX * targetScale;
          const targetTranslateY = centerY - canvasY * targetScale;

          this.smoothTransform(targetTranslateX, targetTranslateY, targetScale);
        }

        resetView() {
          const viewportW = document.body.clientWidth;
          const viewportH = document.body.clientHeight;

          const targetScreenX = viewportW * 0.3;
          const targetScreenY = viewportH / 2;

          const targetX = targetScreenX - mindMapData.x;
          const targetY = targetScreenY - mindMapData.y;

          this.smoothTransform(targetX, targetY, 1.0);
        }

        trackTouch(touch) {
          this.activeTouches.set(touch.identifier, {
            id: touch.identifier,
            clientX: touch.clientX,
            clientY: touch.clientY,
            timestamp: Date.now(),
          });
        }

        untrackTouch(touch) {
          this.activeTouches.delete(touch.identifier);
        }

        startPinch(touches) {
          this.isPinching = true;
          this.wasPinching = false;

          const touch1 = touches[0];
          const touch2 = touches[1];

          this.trackTouch(touch1);
          this.trackTouch(touch2);

          const dx = touch2.clientX - touch1.clientX;
          const dy = touch2.clientY - touch1.clientY;
          this.initialPinch.distance = Math.sqrt(dx * dx + dy * dy);

          this.initialPinch.centerX = (touch1.clientX + touch2.clientX) / 2;
          this.initialPinch.centerY = (touch1.clientY + touch2.clientY) / 2;

          this.initialPinch.scale = this.scale;
          this.initialPinch.translateX = this.translateX;
          this.initialPinch.translateY = this.translateY;
        }

        updatePinch(touches) {
          if (!this.isPinching || touches.length < 2) return;

          const touch1 = touches[0];
          const touch2 = touches[1];

          this.trackTouch(touch1);
          this.trackTouch(touch2);

          const dx = touch2.clientX - touch1.clientX;
          const dy = touch2.clientY - touch1.clientY;
          const currentDistance = Math.sqrt(dx * dx + dy * dy);

          const currentCenterX = (touch1.clientX + touch2.clientX) / 2;
          const currentCenterY = (touch1.clientY + touch2.clientY) / 2;

          const scaleFactor = currentDistance / this.initialPinch.distance;
          let newScale = this.initialPinch.scale * scaleFactor;
          newScale = Math.max(this.minScale, Math.min(this.maxScale, newScale));

          const rect = viewport.getBoundingClientRect();
          const initialViewportX = this.initialPinch.centerX - rect.left;
          const initialViewportY = this.initialPinch.centerY - rect.top;

          const currentViewportX = currentCenterX - rect.left;
          const currentViewportY = currentCenterY - rect.top;

          const initialCanvasX =
            (initialViewportX - this.initialPinch.translateX) / this.initialPinch.scale;
          const initialCanvasY =
            (initialViewportY - this.initialPinch.translateY) / this.initialPinch.scale;

          this.translateX = currentViewportX - initialCanvasX * newScale;
          this.translateY = currentViewportY - initialCanvasY * newScale;
          this.scale = newScale;

          this.applyTransform();
          this.updateDisplay();
        }

        endPinch() {
          this.isPinching = false;
          this.wasPinching = true;
          this.pinchEndTime = Date.now();

          this.activeTouches.clear();

          setTimeout(() => {
            const timeSincePinch = Date.now() - this.pinchEndTime;
            if (timeSincePinch > 300) {
              this.wasPinching = false;
            }
          }, 300);
        }

        canStartDrag() {
          if (this.wasPinching) {
            const timeSincePinch = Date.now() - this.pinchEndTime;
            return timeSincePinch > 150;
          }
          return true;
        }

        startDrag(clientX, clientY) {
          if (!this.canStartDrag()) {
            return;
          }

          this.isDragging = true;
          this.dragStart.x = clientX - this.translateX;
          this.dragStart.y = clientY - this.translateY;
        }

        updateDrag(clientX, clientY) {
          if (!this.isDragging) return;

          this.translateX = clientX - this.dragStart.x;
          this.translateY = clientY - this.dragStart.y;

          this.applyTransform();
        }

        endDrag() {
          this.isDragging = false;
        }

        isMultiTouchInProgress() {
          return this.activeTouches.size >= 2;
        }
      }

      const zoomManager = new EnhancedZoomManager();

      // --- 5. ÊÄùÁª¥ÂØºÂõæÊ∏≤Êüì ---
      function initDataRecursive(node, level) {
        if (level >= 1 && node.children) {
          node.collapsed = true;
        }
        if (node.children) {
          node.children.forEach(c => initDataRecursive(c, level + 1));
        }
      }

      function layoutTree(node) {
        const isLeaf = node.type === 'leaf';
        node.w = isLeaf ? CONFIG.cardWidth : CONFIG.pillWidth;
        node.h = isLeaf ? CONFIG.cardHeight : CONFIG.pillHeight;

        if (!node.children || node.children.length === 0 || node.collapsed) {
          let newNodeYGap = CONFIG.nodeYGap;
          if (node.type === 'branch') {
            newNodeYGap = node.desc ? 100 : 20;
          }
          node.treeHeight = node.h + newNodeYGap;
          return;
        }

        let childrenTotalHeight = 0;
        node.children.forEach(child => {
          layoutTree(child);
          childrenTotalHeight += child.treeHeight;
        });
        node.treeHeight = node.desc ? childrenTotalHeight + 50 : childrenTotalHeight ;
      }

      function assignCoordinates(node, x, y) {
        node.x = x;

        if (!node.children || node.children.length === 0 || node.collapsed) {
          node.y = y;
          flatNodes.push(node);
          return;
        }

        let startY = y - node.treeHeight / 2;
        let cursorY = startY;

        node.children.forEach(child => {
          const childCenterY = cursorY + child.treeHeight / 2;
          assignCoordinates(child, x + node.w + CONFIG.nodeXGap, childCenterY);
          cursorY += child.treeHeight;
        });

        node.y = y;
        flatNodes.push(node);
      }

      function render(preserveViewportPosition = false) {
        let viewportCenterCanvasX = 0;
        let viewportCenterCanvasY = 0;

        if (preserveViewportPosition) {
          const rect = viewport.getBoundingClientRect();
          const viewportCenterX = rect.width / 2;
          const viewportCenterY = rect.height / 2;

          viewportCenterCanvasX = (viewportCenterX - zoomManager.translateX) / zoomManager.scale;
          viewportCenterCanvasY = (viewportCenterY - zoomManager.translateY) / zoomManager.scale;
        }

        domLayer.innerHTML = '';
        svgLayer.innerHTML = '';
        flatNodes = [];

        layoutTree(mindMapData);
        assignCoordinates(mindMapData, 50, 400);

        // flatNodes.forEach(node => {
        //   const el = document.createElement('div');
        //   el.className = `node ${node.type === 'root' ? 'is-root' : ''}`;
        //   el.style.left = `${node.x}px`;
        //   el.style.top = `${node.y - node.h / 2}px`;
        //
        //   let contentHTML = '';
        //   if (node.type === 'leaf') {
        //     contentHTML = `
        //   <div class="node-card">
        //     <div class="card-desc">${cleanNodeText(node.title)}</div>
        //   </div>
        // `;
        //   } else {
        //     contentHTML = `
        //    <div class="node-pill" onclick="toggleNode('${node.id}', event)">
        //     ${cleanNodeText(node.text)}
        //   </div>
        // `;
        //   }
        //
        //   if (node.children && node.children.length > 0) {
        //     contentHTML += `
        //   <div class="toggle-btn ${node.collapsed ? 'collapsed' : ''}"
        //        onclick="toggleNode('${node.id}', event)">
        //        ${node.collapsed ? '+' : '-'}
        //   </div>
        // `;
        //   }
        //
        //   el.innerHTML = contentHTML;
        //   domLayer.appendChild(el);
        // });

        flatNodes.forEach(node => {
          const el = document.createElement('div');
          el.className = `node ${node.type === 'root' ? 'is-root' : ''}`;
          el.style.left = `${node.x}px`;
          el.style.top = `${node.y - node.h / 2}px`;

          let contentHTML = '';
          if (node.type === 'leaf') {
            contentHTML = `
        <div class="node-card">
          <div class="card-desc">${cleanNodeText(node.title)}</div>
        </div>
      `;
          } else {
            // ËøôÈáåÊòØÂÖ≥ÈîÆ‰øÆÊîπÔºöÂú®node-pill‰∏ãÈù¢Ê∑ªÂä†ÊèèËø∞ÊñáÊ°£
            const cleanDesc = cleanNodeText(node.desc || '');
            const hasDesc = cleanDesc.trim() !== '';

            contentHTML = `<div class="node-container">`;

            // ÂéüÊúâÁöÑËÉ∂ÂõäËäÇÁÇπ
            contentHTML += `
        <div class="node-pill" onclick="toggleNode('${node.id}', event)">
          ${cleanNodeText(node.text)}
        </div>
      `;

            // Êñ∞Â¢ûÁöÑÊèèËø∞ÊñáÊ°£ÔºàÂ¶ÇÊûúÊúâÊèèËø∞Ôºâ
            if (hasDesc && node.desc) {
              contentHTML += `
          <div class="node-desc" onclick="toggleNode('${node.id}', event)">
            ${cleanDesc}
          </div>
        `;
            }

            contentHTML += `</div>`;
          }

          // Ê∑ªÂä†ÊäòÂè†/Â±ïÂºÄÊåâÈíÆ
          if (node.children && node.children.length > 0) {
            contentHTML += `
        <div class="toggle-btn ${node.collapsed ? 'collapsed' : ''}"
             onclick="toggleNode('${node.id}', event)">
             ${node.collapsed ? '+' : '-'}
        </div>
      `;
          }

          el.innerHTML = contentHTML;
          domLayer.appendChild(el);
        });

        flatNodes.forEach(node => {
          if (node.children && node.children.length > 0 && !node.collapsed) {
            const startX = node.x + node.w;
            const startY = node.y;

            node.children.forEach(child => {
              const endX = child.x;
              const endY = child.y;

              const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              const cpOffset = CONFIG.nodeXGap * 0.6;
              const d = `M ${startX} ${startY} C ${startX + cpOffset} ${startY}, ${
                endX - cpOffset
              } ${endY}, ${endX} ${endY}`;

              path.setAttribute('d', d);
              path.setAttribute('class', 'connection');
              svgLayer.appendChild(path);
            });
          }
        });

        if (preserveViewportPosition) {
          const rect = viewport.getBoundingClientRect();
          const viewportCenterX = rect.width / 2;
          const viewportCenterY = rect.height / 2;

          zoomManager.translateX = viewportCenterX - viewportCenterCanvasX * zoomManager.scale;
          zoomManager.translateY = viewportCenterY - viewportCenterCanvasY * zoomManager.scale;
          zoomManager.applyTransform();
        }

        zoomManager.updateDisplay();
      }

      // --- 6. ËäÇÁÇπ‰∫§‰∫í ---
      function findNode(node, id) {
        if (node.id === id) return node;
        if (node.children) {
          for (let child of node.children) {
            const res = findNode(child, id);
            if (res) return res;
          }
        }
        return null;
      }

      window.toggleNode = function (id, event) {
        if (event) event.stopPropagation();

        const node = findNode(mindMapData, id);
        if (node) {
          node.collapsed = !node.collapsed;
          render(true);
        }
      };

      // --- ‰∏ÄÈîÆÂ±ïÂºÄ/ÊäòÂè†ÂäüËÉΩ ---
      function expandAllNodes() {
        function expandRecursive(node) {
          if (node.children) {
            node.collapsed = false;
            node.children.forEach(child => expandRecursive(child));
          }
        }
        expandRecursive(mindMapData);
        render(true);
      }

      function collapseAllNodes() {
        function collapseRecursive(node) {
          if (node.children) {
            if (node.type !== 'root') {
              node.collapsed = true;
            }
            node.children.forEach(child => collapseRecursive(child));
          }
        }
        collapseRecursive(mindMapData);
        render(true);
      }

      function toggleExpandCollapseAll() {
        if (isAllExpanded) {
          collapseAllNodes();
        } else {
          expandAllNodes();
        }

        isAllExpanded = !isAllExpanded;
        updateExpandCollapseButton();
      }

      function updateExpandCollapseButton() {
        const toggleBtn = document.getElementById('toggle-expand-btn');

        if (isAllExpanded) {
          toggleBtn.classList.remove('collapsed');
          toggleBtn.classList.add('expanded');
        } else {
          toggleBtn.classList.remove('expanded');
          toggleBtn.classList.add('collapsed');
        }
      }

      // --- 7. ÊîπËøõÁöÑ‰∫ã‰ª∂Â§ÑÁêÜ ---
      function setupEventListeners() {
        document.getElementById('zoom-in-btn').addEventListener('click', () => {
          zoomManager.zoomBy(zoomManager.scaleStep);
        });

        document.getElementById('zoom-out-btn').addEventListener('click', () => {
          zoomManager.zoomBy(-zoomManager.scaleStep);
        });

        document.getElementById('toggle-expand-btn').addEventListener('click', () => {
          toggleExpandCollapseAll();
        });

        // ‰øÆÊîπÔºö‰∏ãËΩΩÂÆåÊï¥ÂØºÂõæÊåâÈíÆ - Áé∞Âú®‰ºöÊ∑ªÂä†Ê∞¥Âç∞
        document.getElementById('download-full-btn').addEventListener('click', async () => {
          RNInterface.postMessage('download_started', {
            action: 'full_map_download',
            timestamp: Date.now(),
            buttonId: 'download-full-btn',
          });
          try {
            const quality = 0.6;

            const imageData = await RNInterface.generateFullMapScreenshot(quality);

            const cleanedImageData = imageData.replace(/\n/g, '');

            // Ê∑ªÂä†Ê∞¥Âç∞
            let watermarkedImageData = cleanedImageData;
            if (RNInterface.WATERMARK_CONFIG.enabled) {
              try {
                const img = new Image();
                await new Promise(resolve => {
                  img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    canvas.width = img.width;
                    canvas.height = img.height;

                    ctx.drawImage(img, 0, 0);

                    // ÁªòÂà∂Ê∞¥Âç∞
                    RNInterface.drawWatermark(ctx, img.width, img.height);

                    watermarkedImageData = canvas.toDataURL('image/png', quality);
                    resolve();
                  };
                  img.onerror = () => {
                    watermarkedImageData = cleanedImageData;
                    resolve();
                  };
                  img.src = cleanedImageData;
                });
              } catch (watermarkError) {
                watermarkedImageData = cleanedImageData;
              }
            }

            const optimizedImageData = await RNInterface.optimizeBase64Size(
              watermarkedImageData,
              'full_map_download',
            );

            RNInterface.postMessage('save_image', {
              imageData: optimizedImageData,
              viewType: 'full',
              quality: quality,
              optimized: cleanedImageData !== optimizedImageData,
              originalSize: cleanedImageData.length,
              finalSize: optimizedImageData.length,
              watermarked:
                RNInterface.WATERMARK_CONFIG.enabled && cleanedImageData !== watermarkedImageData,
            });
          } catch (error) {
            RNInterface.debug('ÂÆåÊï¥ÂØºÂõæÊà™ÂõæÂ§±Ë¥•:', error.message);
          }
          setTimeout(() => {
            RNInterface.postMessage('download_started', {
              action: 'full_map_error',
              timestamp: Date.now(),
              buttonId: 'download-full-btn',
            });
          }, 500);
        });

        document.getElementById('zoom-reset').addEventListener('click', () => {
          zoomManager.resetView();
        });

        viewport.addEventListener('wheel', e => {
          e.preventDefault();

          if (e.ctrlKey || e.metaKey) {
            const delta = e.deltaY > 0 ? -zoomManager.scaleStep : zoomManager.scaleStep;
            zoomManager.zoomBy(delta);
          }
        });

        viewport.addEventListener(
          'touchstart',
          e => {
            if (e.touches.length > 1) {
              e.preventDefault();
            }

            if (e.touches.length === 2) {
              e.preventDefault();
              e.stopPropagation();

              if (zoomManager.isDragging) {
                zoomManager.endDrag();
              }

              zoomManager.startPinch(e.touches);
            } else if (e.touches.length === 1 && !zoomManager.isPinching) {
              const target = e.target;
              if (
                target.closest('.node-pill') ||
                target.closest('.toggle-btn') ||
                target.closest('.action-btn') ||
                target.closest('.control-btn') ||
                target.closest('.reset-view-btn')
              ) {
                return;
              }

              zoomManager.trackTouch(e.touches[0]);

              setTimeout(() => {
                if (!zoomManager.isPinching && !zoomManager.wasPinching) {
                  zoomManager.startDrag(e.touches[0].clientX, e.touches[0].clientY);
                }
              }, 50);
            }
          },
          { passive: false },
        );

        viewport.addEventListener(
          'touchmove',
          e => {
            if (e.touches.length === 2) {
              e.preventDefault();
              e.stopPropagation();
              zoomManager.updatePinch(e.touches);
            } else if (
              e.touches.length === 1 &&
              zoomManager.isDragging &&
              !zoomManager.isPinching &&
              !zoomManager.isMultiTouchInProgress()
            ) {
              e.preventDefault();
              zoomManager.trackTouch(e.touches[0]);
              zoomManager.updateDrag(e.touches[0].clientX, e.touches[0].clientY);
            }
          },
          { passive: false },
        );

        viewport.addEventListener('touchend', e => {
          for (let touch of e.changedTouches) {
            zoomManager.untrackTouch(touch);
          }

          if (zoomManager.isPinching && e.touches.length < 2) {
            zoomManager.endPinch();
          }

          if (zoomManager.isDragging && e.touches.length === 0 && !zoomManager.isPinching) {
            zoomManager.endDrag();
          }
        });

        viewport.addEventListener('touchcancel', e => {
          for (let touch of e.changedTouches) {
            zoomManager.untrackTouch(touch);
          }

          if (zoomManager.isPinching) {
            zoomManager.endPinch();
          }

          if (zoomManager.isDragging) {
            zoomManager.endDrag();
          }
        });

        viewport.addEventListener('pointerdown', e => {
          if (e.pointerType === 'touch') return;

          if (
            e.target.closest('.node-pill') ||
            e.target.closest('.toggle-btn') ||
            e.target.closest('.action-btn') ||
            e.target.closest('.control-btn') ||
            e.target.closest('.reset-view-btn')
          ) {
            return;
          }

          zoomManager.startDrag(e.clientX, e.clientY);
          viewport.style.cursor = 'grabbing';
        });

        window.addEventListener('pointermove', e => {
          if (e.pointerType === 'touch') return;

          if (zoomManager.isDragging) {
            e.preventDefault();
            zoomManager.updateDrag(e.clientX, e.clientY);
          }
        });

        window.addEventListener('pointerup', e => {
          if (e.pointerType === 'touch') return;

          if (zoomManager.isDragging) {
            zoomManager.endDrag();
            viewport.style.cursor = 'grab';
          }
        });

        document.addEventListener('gesturestart', e => e.preventDefault());
        document.addEventListener('gesturechange', e => e.preventDefault());
        document.addEventListener('gestureend', e => e.preventDefault());
      }

      // --- 8. ÂàùÂßãÂåñ ---
      function initializeApp() {
        initDataRecursive(mindMapData, 0);
        render();

        const viewportW = document.body.clientWidth;
        const viewportH = document.body.clientHeight;
        const targetScreenX = viewportW * 0.3;
        const targetScreenY = viewportH / 2;

        zoomManager.translateX = targetScreenX - mindMapData.x;
        zoomManager.translateY = targetScreenY - mindMapData.y;
        zoomManager.applyTransform();
        zoomManager.updateDisplay();

        function initializeButtonState() {
          const toggleBtn = document.getElementById('toggle-expand-btn');
          toggleBtn.classList.add('collapsed');
          isAllExpanded = false;
        }

        initializeButtonState();
        setupEventListeners();
        RNInterface.setupMessageListener();

        setTimeout(() => {
          RNInterface.postMessage('webview_ready', {
            ready: true,
            version: '1.0.0',
          });

          RNInterface.requestData();
        }, 100);
      }

      window.addEventListener('load', () => {
        initializeApp();
      });

      window.RNInterface = RNInterface;
      window.mindMapData = mindMapData;
      window.expandAllNodes = expandAllNodes;
      window.collapseAllNodes = collapseAllNodes;
      window.toggleExpandCollapseAll = toggleExpandCollapseAll;

      window.saveScreenshot = function (viewType = 'current') {
        RNInterface.handleScreenshotRequest(viewType);
      };

      window.getCurrentViewScreenshot = function () {
        return RNInterface.generateCurrentViewScreenshot();
      };

      window.getFullMapScreenshot = function () {
        return RNInterface.generateFullMapScreenshot();
      };

      window.updateMindMapData = function (newData) {
        RNInterface.updateData(newData);
      };

      window.clearMindMapData = function () {
        RNInterface.clearData();
      };

      window.requestMindMapData = function () {
        RNInterface.requestData();
      };
    </script>
  </body>
</html>
